/* automatically generated by rust-bindgen 0.58.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const WINTUN_MAX_POOL: u32 = 256;
pub const WINTUN_MIN_RING_CAPACITY: u32 = 131072;
pub const WINTUN_MAX_RING_CAPACITY: u32 = 67108864;
pub const WINTUN_MAX_IP_PACKET_SIZE: u32 = 65535;
pub type BOOL = ::std::os::raw::c_uchar;
pub type BYTE = ::std::os::raw::c_uchar;
pub type LPARAM = *mut ::std::os::raw::c_void;
pub type HANDLE = *mut ::std::os::raw::c_void;
pub type WCHAR = ::std::os::raw::c_ushort;
pub type DWORD = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GUID {
    pub __bindgen_anon_1: _GUID__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GUID__bindgen_ty_1 {
    pub __bindgen_anon_1: _GUID__bindgen_ty_1__bindgen_ty_1,
    pub Bytes: [::std::os::raw::c_uchar; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUID__bindgen_ty_1__bindgen_ty_1 {
    pub a: ::std::os::raw::c_ulonglong,
    pub b: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout__GUID__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GUID__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_GUID__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUID__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_GUID__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GUID__bindgen_ty_1__bindgen_ty_1>())).a as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GUID__bindgen_ty_1__bindgen_ty_1>())).b as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(b)
        )
    );
}
#[test]
fn bindgen_test_layout__GUID__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GUID__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_GUID__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUID__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GUID__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GUID__bindgen_ty_1>())).Bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID__bindgen_ty_1),
            "::",
            stringify!(Bytes)
        )
    );
}
#[test]
fn bindgen_test_layout__GUID() {
    assert_eq!(
        ::std::mem::size_of::<_GUID>(),
        16usize,
        concat!("Size of: ", stringify!(_GUID))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUID>(),
        8usize,
        concat!("Alignment of ", stringify!(_GUID))
    );
}
pub type GUID = _GUID;
pub type WINTUN_ADAPTER_HANDLE = *mut ::std::os::raw::c_void;
pub type WINTUN_SESSION_HANDLE = *mut ::std::os::raw::c_void;
pub type WINTUN_ENUM_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(Adapter: WINTUN_ADAPTER_HANDLE, Param: LPARAM) -> BOOL,
>;
pub const WINTUN_LOGGER_LEVEL_WINTUN_LOG_INFO: WINTUN_LOGGER_LEVEL = 0;
pub const WINTUN_LOGGER_LEVEL_WINTUN_LOG_WARN: WINTUN_LOGGER_LEVEL = 1;
pub const WINTUN_LOGGER_LEVEL_WINTUN_LOG_ERR: WINTUN_LOGGER_LEVEL = 2;
pub type WINTUN_LOGGER_LEVEL = ::std::os::raw::c_uint;
pub type WINTUN_LOGGER_CALLBACK =
    ::std::option::Option<unsafe extern "C" fn(Level: WINTUN_LOGGER_LEVEL, Message: *const WCHAR)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NET_LUID_LH {
    pub Value: ::std::os::raw::c_ulonglong,
    pub Info: _NET_LUID_LH__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _NET_LUID_LH__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout__NET_LUID_LH__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NET_LUID_LH__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_NET_LUID_LH__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NET_LUID_LH__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_NET_LUID_LH__bindgen_ty_1))
    );
}
impl _NET_LUID_LH__bindgen_ty_1 {
    #[inline]
    pub fn Reserved(&self) -> ::std::os::raw::c_ulonglong {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ::std::os::raw::c_ulonglong) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn NetLuidIndex(&self) -> ::std::os::raw::c_ulonglong {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 24u8) as u64) }
    }
    #[inline]
    pub fn set_NetLuidIndex(&mut self, val: ::std::os::raw::c_ulonglong) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn IfType(&self) -> ::std::os::raw::c_ulonglong {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_IfType(&mut self, val: ::std::os::raw::c_ulonglong) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved: ::std::os::raw::c_ulonglong,
        NetLuidIndex: ::std::os::raw::c_ulonglong,
        IfType: ::std::os::raw::c_ulonglong,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(24usize, 24u8, {
            let NetLuidIndex: u64 = unsafe { ::std::mem::transmute(NetLuidIndex) };
            NetLuidIndex as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let IfType: u64 = unsafe { ::std::mem::transmute(IfType) };
            IfType as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__NET_LUID_LH() {
    assert_eq!(
        ::std::mem::size_of::<_NET_LUID_LH>(),
        8usize,
        concat!("Size of: ", stringify!(_NET_LUID_LH))
    );
    assert_eq!(
        ::std::mem::align_of::<_NET_LUID_LH>(),
        8usize,
        concat!("Alignment of ", stringify!(_NET_LUID_LH))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NET_LUID_LH>())).Value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NET_LUID_LH),
            "::",
            stringify!(Value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NET_LUID_LH>())).Info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NET_LUID_LH),
            "::",
            stringify!(Info)
        )
    );
}
pub type NET_LUID_LH = _NET_LUID_LH;
pub type PNET_LUID_LH = *mut _NET_LUID_LH;
pub type NET_LUID = NET_LUID_LH;
extern crate libloading;
pub struct wintun {
    __library: ::libloading::Library,
    pub WintunCreateAdapter: Result<
        unsafe extern "C" fn(
            Pool: *const WCHAR,
            Name: *const WCHAR,
            RequestedGUID: *const GUID,
            RebootRequired: *mut BOOL,
        ) -> WINTUN_ADAPTER_HANDLE,
        ::libloading::Error,
    >,
    pub WintunOpenAdapter: Result<
        unsafe extern "C" fn(Pool: *const WCHAR, Name: *const WCHAR) -> WINTUN_ADAPTER_HANDLE,
        ::libloading::Error,
    >,
    pub WintunDeleteAdapter: Result<
        unsafe extern "C" fn(
            Adapter: WINTUN_ADAPTER_HANDLE,
            ForceCloseSessions: BOOL,
            RebootRequired: *mut BOOL,
        ) -> BOOL,
        ::libloading::Error,
    >,
    pub WintunEnumAdapters: Result<
        unsafe extern "C" fn(
            Pool: *const WCHAR,
            Callback: WINTUN_ENUM_CALLBACK,
            Param: LPARAM,
        ) -> BOOL,
        ::libloading::Error,
    >,
    pub WintunFreeAdapter:
        Result<unsafe extern "C" fn(Adapter: WINTUN_ADAPTER_HANDLE), ::libloading::Error>,
    pub WintunGetAdapterLuid: Result<
        unsafe extern "C" fn(Adapter: WINTUN_ADAPTER_HANDLE, Luid: *mut NET_LUID),
        ::libloading::Error,
    >,
    pub WintunGetAdapterName: Result<
        unsafe extern "C" fn(Adapter: WINTUN_ADAPTER_HANDLE, Name: *mut WCHAR) -> BOOL,
        ::libloading::Error,
    >,
    pub WintunSetAdapterName: Result<
        unsafe extern "C" fn(Adapter: WINTUN_ADAPTER_HANDLE, Name: *const WCHAR) -> BOOL,
        ::libloading::Error,
    >,
    pub WintunGetRunningDriverVersion: Result<unsafe extern "C" fn() -> DWORD, ::libloading::Error>,
    pub WintunSetLogger:
        Result<unsafe extern "C" fn(NewLogger: WINTUN_LOGGER_CALLBACK), ::libloading::Error>,
    pub WintunStartSession: Result<
        unsafe extern "C" fn(
            Adapter: WINTUN_ADAPTER_HANDLE,
            Capacity: DWORD,
        ) -> WINTUN_SESSION_HANDLE,
        ::libloading::Error,
    >,
    pub WintunEndSession:
        Result<unsafe extern "C" fn(Session: WINTUN_SESSION_HANDLE), ::libloading::Error>,
    pub WintunGetReadWaitEvent:
        Result<unsafe extern "C" fn(Session: WINTUN_SESSION_HANDLE) -> HANDLE, ::libloading::Error>,
    pub WintunReceivePacket: Result<
        unsafe extern "C" fn(Session: WINTUN_SESSION_HANDLE, PacketSize: *mut DWORD) -> *mut BYTE,
        ::libloading::Error,
    >,
    pub WintunReleaseReceivePacket: Result<
        unsafe extern "C" fn(Session: WINTUN_SESSION_HANDLE, Packet: *const BYTE),
        ::libloading::Error,
    >,
    pub WintunAllocateSendPacket: Result<
        unsafe extern "C" fn(Session: WINTUN_SESSION_HANDLE, PacketSize: DWORD) -> *mut BYTE,
        ::libloading::Error,
    >,
    pub WintunSendPacket: Result<
        unsafe extern "C" fn(Session: WINTUN_SESSION_HANDLE, Packet: *const BYTE),
        ::libloading::Error,
    >,
}
impl wintun {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let WintunCreateAdapter = __library.get(b"WintunCreateAdapter\0").map(|sym| *sym);
        let WintunOpenAdapter = __library.get(b"WintunOpenAdapter\0").map(|sym| *sym);
        let WintunDeleteAdapter = __library.get(b"WintunDeleteAdapter\0").map(|sym| *sym);
        let WintunEnumAdapters = __library.get(b"WintunEnumAdapters\0").map(|sym| *sym);
        let WintunFreeAdapter = __library.get(b"WintunFreeAdapter\0").map(|sym| *sym);
        let WintunGetAdapterLuid = __library.get(b"WintunGetAdapterLuid\0").map(|sym| *sym);
        let WintunGetAdapterName = __library.get(b"WintunGetAdapterName\0").map(|sym| *sym);
        let WintunSetAdapterName = __library.get(b"WintunSetAdapterName\0").map(|sym| *sym);
        let WintunGetRunningDriverVersion = __library
            .get(b"WintunGetRunningDriverVersion\0")
            .map(|sym| *sym);
        let WintunSetLogger = __library.get(b"WintunSetLogger\0").map(|sym| *sym);
        let WintunStartSession = __library.get(b"WintunStartSession\0").map(|sym| *sym);
        let WintunEndSession = __library.get(b"WintunEndSession\0").map(|sym| *sym);
        let WintunGetReadWaitEvent = __library.get(b"WintunGetReadWaitEvent\0").map(|sym| *sym);
        let WintunReceivePacket = __library.get(b"WintunReceivePacket\0").map(|sym| *sym);
        let WintunReleaseReceivePacket = __library
            .get(b"WintunReleaseReceivePacket\0")
            .map(|sym| *sym);
        let WintunAllocateSendPacket = __library.get(b"WintunAllocateSendPacket\0").map(|sym| *sym);
        let WintunSendPacket = __library.get(b"WintunSendPacket\0").map(|sym| *sym);
        Ok(wintun {
            __library,
            WintunCreateAdapter,
            WintunOpenAdapter,
            WintunDeleteAdapter,
            WintunEnumAdapters,
            WintunFreeAdapter,
            WintunGetAdapterLuid,
            WintunGetAdapterName,
            WintunSetAdapterName,
            WintunGetRunningDriverVersion,
            WintunSetLogger,
            WintunStartSession,
            WintunEndSession,
            WintunGetReadWaitEvent,
            WintunReceivePacket,
            WintunReleaseReceivePacket,
            WintunAllocateSendPacket,
            WintunSendPacket,
        })
    }
    pub unsafe fn WintunCreateAdapter(
        &self,
        Pool: *const WCHAR,
        Name: *const WCHAR,
        RequestedGUID: *const GUID,
        RebootRequired: *mut BOOL,
    ) -> WINTUN_ADAPTER_HANDLE {
        (self
            .WintunCreateAdapter
            .as_ref()
            .expect("Expected function, got error."))(
            Pool, Name, RequestedGUID, RebootRequired
        )
    }
    pub unsafe fn WintunOpenAdapter(
        &self,
        Pool: *const WCHAR,
        Name: *const WCHAR,
    ) -> WINTUN_ADAPTER_HANDLE {
        (self
            .WintunOpenAdapter
            .as_ref()
            .expect("Expected function, got error."))(Pool, Name)
    }
    pub unsafe fn WintunDeleteAdapter(
        &self,
        Adapter: WINTUN_ADAPTER_HANDLE,
        ForceCloseSessions: BOOL,
        RebootRequired: *mut BOOL,
    ) -> BOOL {
        (self
            .WintunDeleteAdapter
            .as_ref()
            .expect("Expected function, got error."))(
            Adapter, ForceCloseSessions, RebootRequired
        )
    }
    pub unsafe fn WintunEnumAdapters(
        &self,
        Pool: *const WCHAR,
        Callback: WINTUN_ENUM_CALLBACK,
        Param: LPARAM,
    ) -> BOOL {
        (self
            .WintunEnumAdapters
            .as_ref()
            .expect("Expected function, got error."))(Pool, Callback, Param)
    }
    pub unsafe fn WintunFreeAdapter(&self, Adapter: WINTUN_ADAPTER_HANDLE) -> () {
        (self
            .WintunFreeAdapter
            .as_ref()
            .expect("Expected function, got error."))(Adapter)
    }
    pub unsafe fn WintunGetAdapterLuid(
        &self,
        Adapter: WINTUN_ADAPTER_HANDLE,
        Luid: *mut NET_LUID,
    ) -> () {
        (self
            .WintunGetAdapterLuid
            .as_ref()
            .expect("Expected function, got error."))(Adapter, Luid)
    }
    pub unsafe fn WintunGetAdapterName(
        &self,
        Adapter: WINTUN_ADAPTER_HANDLE,
        Name: *mut WCHAR,
    ) -> BOOL {
        (self
            .WintunGetAdapterName
            .as_ref()
            .expect("Expected function, got error."))(Adapter, Name)
    }
    pub unsafe fn WintunSetAdapterName(
        &self,
        Adapter: WINTUN_ADAPTER_HANDLE,
        Name: *const WCHAR,
    ) -> BOOL {
        (self
            .WintunSetAdapterName
            .as_ref()
            .expect("Expected function, got error."))(Adapter, Name)
    }
    pub unsafe fn WintunGetRunningDriverVersion(&self) -> DWORD {
        (self
            .WintunGetRunningDriverVersion
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn WintunSetLogger(&self, NewLogger: WINTUN_LOGGER_CALLBACK) -> () {
        (self
            .WintunSetLogger
            .as_ref()
            .expect("Expected function, got error."))(NewLogger)
    }
    pub unsafe fn WintunStartSession(
        &self,
        Adapter: WINTUN_ADAPTER_HANDLE,
        Capacity: DWORD,
    ) -> WINTUN_SESSION_HANDLE {
        (self
            .WintunStartSession
            .as_ref()
            .expect("Expected function, got error."))(Adapter, Capacity)
    }
    pub unsafe fn WintunEndSession(&self, Session: WINTUN_SESSION_HANDLE) -> () {
        (self
            .WintunEndSession
            .as_ref()
            .expect("Expected function, got error."))(Session)
    }
    pub unsafe fn WintunGetReadWaitEvent(&self, Session: WINTUN_SESSION_HANDLE) -> HANDLE {
        (self
            .WintunGetReadWaitEvent
            .as_ref()
            .expect("Expected function, got error."))(Session)
    }
    pub unsafe fn WintunReceivePacket(
        &self,
        Session: WINTUN_SESSION_HANDLE,
        PacketSize: *mut DWORD,
    ) -> *mut BYTE {
        (self
            .WintunReceivePacket
            .as_ref()
            .expect("Expected function, got error."))(Session, PacketSize)
    }
    pub unsafe fn WintunReleaseReceivePacket(
        &self,
        Session: WINTUN_SESSION_HANDLE,
        Packet: *const BYTE,
    ) -> () {
        (self
            .WintunReleaseReceivePacket
            .as_ref()
            .expect("Expected function, got error."))(Session, Packet)
    }
    pub unsafe fn WintunAllocateSendPacket(
        &self,
        Session: WINTUN_SESSION_HANDLE,
        PacketSize: DWORD,
    ) -> *mut BYTE {
        (self
            .WintunAllocateSendPacket
            .as_ref()
            .expect("Expected function, got error."))(Session, PacketSize)
    }
    pub unsafe fn WintunSendPacket(
        &self,
        Session: WINTUN_SESSION_HANDLE,
        Packet: *const BYTE,
    ) -> () {
        (self
            .WintunSendPacket
            .as_ref()
            .expect("Expected function, got error."))(Session, Packet)
    }
}
